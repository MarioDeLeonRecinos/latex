\documentclass[11pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsfonts, amsmath, amssymb}
\usepackage[none]{hyphenat}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{float}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{comment}
\usepackage[nottoc, notlot, notlof]{tocbibind}

\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{\slshape\MakeUppercase{Método de Newton para sistemas no lineales}}
%\fancyhead[R]{\slshape{Student Name}}
\fancyfoot[C]{\thepage}
%\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\DeclarePairedDelimiter\norm{\lVert}{\rVert}%

% Swap the definition of \abs* and \norm*, so that \abs
% and \norm resizes the size of the brackets, and the 
% starred version does not.
\makeatletter
\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
%
\let\oldnorm\norm
\def\norm{\@ifstar{\oldnorm}{\oldnorm*}}
\makeatother

\parindent 0ex
%\setlength{\parindent}{4em}
%\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.5}

\begin{document}
\begin{titlepage}

\begin{center}
%\vspace*{1cm}
\Large{\textbf{Analisis Numerico}}\\
\Large{\textbf{Proyecto Final}}\\
\vfill
\line(1,0){500}\\[1mm]

\huge{\textbf{Método de Newton para sistemas no lineales}}\\[3mm]
\Large{\textbf{- Implementacion y teoria del metodo -}}\\[1mm]

\line(1,0){500}\\
\vfill
00076015 Carlos Javier Burgos Martinez\\
00006715 David Bejamín Ayala Giralt\\
00388913 Diego José Eguizabal Liu\\
00058615 Karla Esperanza López Méndez\\
00353715 Mario Cecilio De Leon Recinos\\
00004315 Rafael Enrique Cruz Aparicio \\
00088116 Yury Alejandro Rivera Quintanilla\\
\vfill
\today\\

\end{center}

\end{titlepage}

\tableofcontents
\thispagestyle{empty}
\clearpage

\setcounter{page}{1}

\section{Definiciones}

El problema computacional que se tiene a resolver es solucion de ecuaciones no lineales, el cual sera resuelto con el metodo de newton para ecuaciones no lineales. Este metodo tiene un procedimiento algoritmico para efectuar la transformacion en una situacion mas general.\\

Para construir dicho algoritmo que lleve a una solucion del metodo de punto-fijo en un caso unidimensional, obtuvimos una funcion $\phi$ con las propiedades $$g(x)=x-\phi(x)f(x)$$ da una convergencia cuadratica en el punto fijo $p$ de la funcion $g$.De esta condicion el metodo de Newton evoluciono al escoger $\phi(x)=1/f'(x)$ asumiendo que $f'(x)\neq0$.\\

Un enfoque similar in el caso $n$-dimensional implica una matriz

\begin{equation}
A=
\begin{bmatrix}
    a_{11}       & a_{12} & \dots & a_{1n} \\
    a_{21}       & a_{22} & \dots & a_{2n} \\
    \vdots & \vdots & \ddots  & \vdots\\
    a_{n1}       & a_{n2} & \dots & a_{nn}
    \label{matrix:A}    
\end{bmatrix}
\end{equation}


donde cada una de las entradas $a_{ij}(x)$ es una funcion de $\mathbb{R}^n$ a $\mathbb{R}$ . Esto requiere que $A(x)$ sea encontrado para que $$\mathbf{G(x)=x-A(x)^{-1}F(x)}$$ genere una convergencia cuadratica para la solucion $\mathbf{F(x)=0}$, asumiendo que $A(x)$ es no singular en el punto fijo $\mathbf{p}$ de $\mathbf{G}$.\\

Suponemos que $p$ es una solucion de $G(x)=x$. Si existe un numero $\delta>0$ con la propiedad que

\begin{enumerate}[label=(\roman*)]

	\item $\partial g_i / \partial x_j$ sea continua en $N_\delta=x|\quad \norm{x-p}$ para toda $i=1,2,...,n$ y toda $j=1,2,///,n;$
	\item $\partial^2 g_i(x) / \partial x_j\partial x_k$ sea continua y $\abs{ \partial^2 g_i(x)/(\partial x_j\partial x_k)}\leq M$ para alguna constante M siempre que $x\in N_\delta$ para toda $i=1,2,...,n, j=1,2,...,n$ y toda $k=1,2,...,n;$ 
	\item $\partial g_i(p) /\partial x_k =0$ para toda $i=1,2,...,n$ y toda $k=1,2,...,n.$

\end{enumerate}

Entonces existe un numero $\hat{\delta}\leq \delta$ tal que la sucesion generada por $x^k=G(x^{k-1})$
converge cuadraticamente a $p$ para cualquier eleccion de $x^0$ a condicion de que $\quad \norm{x^0-p}<\hat{\delta}$
\begin{center}
$\quad \norm{x^k-p}_\infty \leq \frac{n^2M}{2}\quad \norm{x^{k-1}-p}_\infty^2$ para toda k$\geq 1$
\end{center}
Para utilizar el teorema supongamos que $A(x)$ es una matriz de $n X n$ de funcio­nes de $\mathbb{R}^n$ a $\mathbb{R}$ en la forma de la ecuacion \ref{matrix:A}, cuyos elementos específicos se escoge­rán más adelante. Supongamos además que $A(x)$ es no singular cerca de una solución $p$ de $F(x)=O$ , y denotemos con $b_{ij}(x)$ el elemento de $A(x)^{-1}$ en el i-ésimo renglón y en la j-ésima columna.

\begin{table}[H]
	\centering
		\begin{tabular}{|c|c|c|c|}\hline
		$x$ &0&1&2\\ \hline
		$f(x)$ &3&6&9\\ \hline		
		\end{tabular}
	\caption{Caption goes here}
	\label{tab:data1}
\end{table}


\section{Desarrollo del programa}
Este programa fue desarrolado con la intención que permita resolver sistemas de ecuaciones no lineales de manera numerica usando el metodo de Newton adaptado para estos tipos de sistemas. Estos sistemas son un conjunto de ecuaciones no lineales que tienen multiples variables y describen fenomenos bastante complejos como lo podrian ser los que se simulan por computadora. 

\subsection{Algoritmo}
El algoritmo que utilizamos en este caso fue el  método de Newton adaptado para trabajar con sistemas no lineasles de $n$ funciones y $n$ variables que mapean $\mathbb{R}^3$ a $\mathbb{R}^3$ de forma iterativa. Como ya se mensiono en esta forma el metodo de Newton debe trabajar para resolver varias ecuaciones con varias incognitas es decir un sistema de ecuaciones, la caracteristica de este sistema esta vez es que es uno no linal por lo que los metodos combencionales para resolver SEL resultan no utiles. A consecuencia de esto se necesita otro tipo de método. Uno de los candidatos es el método de Newton, sin embargo este metodo esta definido para una variable y se deduce de un polinomio de series de potencias, un polinomio de taylor de segundo grado para ser precisos. Por lo que este metodo no puede aplicarse directamente al sistema y  necesita ser adaptado. Descrinimos los cambios de forma general a continuación.\\

Si recordamos la forma unidemencional del metodo de Newton:\\
\begin{center}
$x_{k+1} = x_{k} + \frac{f(x_{k})}{f^\prime(x_{k})} \label{eq:1}$\\
\end{center}

Se observa que cada iteracion estad dada por el valor resultante de la iteración anterior o del valor inicial mas la función evaluada en ese mismo punto dividido entre la derivada de la función evaluada en ese mismo punto nuevamente. El primer cambio necesario para usar el método de Newton en un sistema no lineal es definirlo de forma matricial tal, esto se logra desarrollando una aproximacion por polinomio de taylor de grado 2 a la función $f(x_{0},x_{1},x_{3},...x_{n})$. De este ultimo pilinomio agrupamos todas las derivadas parciales y las convertimos una forma matricial generado asi la matriz Jacobiana que al invertirla  juega el mismo papel que la derivada de la función para el caso unidimensional o el metodo de Newton sin adaptar. El siguiente cambio miportante es que ya no se itera sobre un punto si no sobre dos vectores columna, el primero que contiene las coordenadas del punto de la iteracion anterior o de la inicial y el segundo es un vector con las coordenadas imagenes de $f(x_{n})$.\\
El metodo adaptado para resolver sistemas de ecuaciones no lineales aun posee una forma y caracteristicas similares a la su forma inicial. La diferencia radica en que el metodo generalizado no trabaja iterando sobre $\mathbb{R}$ para encontrar la raiz de $f$ sino que este itera sobre un campo vectorial de $\mathbb{R}^n$ definido por las $n$ funciones que necesita resolver. En otras palabras el metodo retorna como respuesta un vector columna con las soluciones o el vector solución.\\

Forma generarizada del metodo de Newton.
 
\begin{center}
$\bar{X}_{k+1} = \bar{X}_{k} + {J(\bar{X})}^{-1}F(\bar{X})  \label{eq:2}$
\end{center}

Pero para este caso el papel de la derivada lo juega la matriz de derivadas parciales de cada funcion es decir la matriz jacobiana que nos permite maperar  $\mathbb{R}^3$ a $\mathbb{R}^3$ y en lugar iterar sobre un punto $x$ de $\mathbb{R}$  ahora iteramos en el vector $\bar{X}$. 

Desafortunadamente el cálculo de una matriz Jacobiana luego deve ser invertido y el calculo de una matriz inversa resulta demaciado costoso en terminos de procesamiento por lo que se opto por usar una forma alternativa método que genera un SEL al final el cual es mucho mas rapido de resolver\\

\begin{center}
$J(\bar{X}_{k})y = -F(\bar{X}_{k}) $
\end{center}

Siendo $y$ un vector que satisfaga la igualdad, es de la necesidad de hayar las coordenadas de ese vector de donde se origina el SEL previamente mencionado. Finalmente la respuesta para esa iteracion sera la suma del vector $\bar{X}$ y el vector $y$


\subsection{Pseudocódigo}
El Pseudocódigo para el proyecto se divide en 3 bloques principales de codigo:
\begin{enumerate}
  \item Configuración de parametros
  \item Bucle
  \item Salida
\end{enumerate}

\subsubsection{Configuración de parametros}
Durante la configuración de parametros el programa necesita recibir como entrada varias cosas, entre ellas estan el número  $n$ de incognitas y de funciones que se desea calcular, luego la precision deseada que luego servira para saber en que momento detener el programa. Finalmente se necesitaran las ecuaciones que deben ser solucionadas.

\subsubsection{Bucle}
Esta es la parte computacionalmente mas exigente del programa, en esta parte se necesitan calcular los siguientes valores
\begin{itemize}
  \item Matris Jacobiana de la iteración
  \item El vector $F(\bar{X})$
  \item Un SEL al fin de cada iteración
\end{itemize}
\subsubsection{Salida}
Esta es la parte donde en caso de exito los valores numericos obtenidos en el vector columna se le muestran al suaurio en un formato amigable asi como la tabla con las iteraciones realizadas, o en caso de fallo un mensaje de error y si es posible las tablas de iteracion que el programa haya logrado ejecutar.  
%\thispagestyle{empty}
\clearpage
\bibliographystyle{plain}
\nocite{*}
\bibliography{bibliografia}

\end{document}